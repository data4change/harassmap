<!DOCTYPE html>
<head>
	<meta charset="utf-8">
	<title>HarassMap Threads in the Stories</title>
  <link href="https://fonts.googleapis.com/css?family=Oswald:300,400,700" rel="stylesheet">
	<style>
		/*
		hm-red: #ba1e43 
		hm-blue: #228bbb
		*/
		body {
			margin: 0;
			padding: 0;
			background-color: #fff;
			font-family: 'Oswald', sans-serif;
		}

		h1 {
			font-family: 'Oswald', sans-serif;
			font-weight: 500;
      text-align: center;
		}

		.label text {
      fill: #666;
      font-family: 'Oswald', sans-serif;
    }

    .node text {
      fill: #111;
      cursor: pointer;
      font-family: 'Oswald', sans-serif;
    }

    .node.setting text {
      font-weight: 300;
    }

    .node.incident text {
      font-weight: 400;
    }

    .node.reaction text {
      font-weight: 700;
    }
	</style>
</head>
<body>
	<h1>Threads in the Stories</h1>
	<div id='vis'></div>

	<script src="lib/d3.min.js"></script>
	<script>
		var e = document.documentElement,
    		g = document.getElementsByTagName('body')[0],
    		fontHeight = 38,
    		fontMargin = fontHeight * 0.40,
    		lineHeight = fontHeight + fontMargin,
    		topOffset = 100,
				winWidth = window.innerWidth || e.clientWidth || g.clientWidth,
    		winHeight = window.innerHeight|| e.clientHeight|| g.clientHeight,
    		visWidth = winWidth,
    		visHeight = winHeight * 0.9,
        marginWidth = visWidth * 0.05;

    var themeNames = ['setting', 'incident', 'reaction'],
        themeLine = visHeight / 2,
        themeUnit = (visWidth - (marginWidth * 7)) / 2;

  	var svg = d3.select("#vis").append("svg")
  		.attr("width", visWidth);

  	var countScale = d3.scaleLog()
        .range([0.3, 1]);

    d3.json("graph.json", function(error, graph) {
      if (error) throw error;
      // console.log(graph);
      var themes = {};
      var nodes = graph.nodes.filter(function(n) {
      	if (themeNames.indexOf(n.theme) == -1) {
      		return false;
      	}
      	if (!themes[n.theme]) {
      		themes[n.theme] = [];
      	}
      	n.count = n.cases.length;
      	n.linked = [];
      	n.stacks = {};
      	for (i in graph.links) {
      		var link = graph.links[i],
      				source = graph.nodes[link.source],
      				target = graph.nodes[link.target];

      		if (source.id == n.id && target.theme && target.theme != n.theme) {
      			n.linked.push(target.id);
 						n.stacks[target.theme] = n.stacks[target.theme] ? n.stacks[target.theme] + 1 : 1;
      		}
      		if (target.id == n.id && source.theme && source.theme != n.theme) {
      			n.linked.push(source.id);
      			n.stacks[t] = n.stacks[t] ? n.stacks[t] + 1 : 1;
      		}
      	}
      	themes[n.theme].push(n);
      	return true;
      });
      // console.log(themes);

      countScale.domain(d3.extent(nodes, function(n) { return n.count; }));

      var columnMax = 0;
      for (var t in themes) {
      	var name = themes[t];
      	columnMax = Math.max(columnMax, themes[t].length);
      }
      svg.attr('height', topOffset + (columnMax * lineHeight));

      var label = svg.append("g")
          .attr("class", "labels")
        .selectAll("g")
        .data(themeNames)
        .enter().append("g")
          .classed("label", true)
          .attr("transform", function(d, i) {
          	var x = marginWidth + (i * themeUnit);
            var y = 100 - (lineHeight);
            return 'translate(' + [x, y] + ')';
          });

      label.append("text")
        .attr("text-anchor", "left")
        .text(function(d) {
        	return d.toUpperCase();
        })
        .style("font-size", fontHeight / 2);

      var node = svg.append("g")
          .attr("class", "nodes")
        .selectAll("g")
        .data(nodes)
        .enter().append("g")
          .classed("node", true)
          .classed("setting", function(d) { return d.theme == 'setting'; })
          .classed("incident", function(d) { return d.theme == 'incident'; })
          .classed("reaction", function(d) { return d.theme == 'reaction'; })
          .attr("transform", function(d) {
            d.x = marginWidth + (themeNames.indexOf(d.theme) * themeUnit);
            d.y = topOffset + themes[d.theme].indexOf(d) * lineHeight;
            return 'translate(' + [d.x, d.y] + ')';
          });

      node.style("opacity", 0)
      		.transition()
      		.duration(function(d) {
      			return Math.random() * 1000 + 100;
      		})
      		.delay(function(d) {
      			return Math.random() * 4000 + 0;
      		})
      		.style("opacity", function(d) {
        		return countScale(d.count);
      		});

      node.append("text")
        .attr("class", "title")
        .attr("text-anchor", "left")
        .style("opacity", 1)
        .text(function(d){
        	var label = d.label || d.id;
        	return label.toUpperCase();
        })
        .style("font-size", fontHeight);

      node.on('mouseover', function(d) {
      	// get connected nodes.
      	// console.log(d);
      	var offsets = {};
      	for (var i in themeNames) {
      		var theme = themeNames[i];
      		offsets[theme] = d.y;
      	}

      	node
     			// .transition()
     			// .duration(100)
     			.attr("transform", function(n) {
     				if (n.theme != d.theme) {
     					if (d.linked.indexOf(n.id) == -1) {
     						return 'translate(' + [n.x, n.y] + ') scale(1, 0)';
     					}
     					var offset = offsets[n.theme];
     					offsets[n.theme] = offset + lineHeight;
     					return 'translate(' + [n.x, offset] + ')';
     				}
     				return 'translate(' + [n.x, n.y] + ')';
     			});
      });

      node.on('mouseout', function(d) {
      	node
     			// .transition()
     			// .duration(100)
     			.attr("transform", function(n) {
     				return 'translate(' + [n.x, n.y] + ')';
     			});
      });
    });
	</script>
</body>
